<html>
<head>
<title>
InfoPyuta: ぴゅう太エミュレータ for Win32
</title>
</head>
<body>

<h2>
InfoPyuta: ぴゅう太エミュレータ for Win32<br>
Copyright (c) 2001 Jay's Factory<br>
</h2>

<h3>はじめにお読みください</h3>

　InfoPyutaは，Windows上で動作する，空想上のぴゅう太エミュレータです．現時点では，商用ゲームなどは，動作しないと思います．なお，｢空想上｣の意味については，以下で詳細に述べていますので，そちらを参照ください．
　
<h4>注意事項</h4>
<ul>
<li>ROMイメージは，各自御用意下さい</li>
<li>ROMイメージの入手方法に関する御質問は，御遠慮ください</li>
<li>上記の事項に同意いただけない場合には，本ソフトウェアは御利用いただけません</li>
</ul>

<h4>更新状況</h4>
<ul>
<li> v0.02J (01/07/01)</li>
<ul>
<li>CPU: スキャンライン制御機能を追加</li>
<li>CPU: CPU,VDP間タイミング制御機能を追加</li>
<li>VDP: スプライト機能(8x8, 16x16, 拡大機能)を追加</li>
<li>VDP: VDPステータスのVBLANKフラグ制御を追加</li>
<li>主記憶: 外部RAM機能を削除</li>
<li>I/O: VDP RAM読み込み機能(>8800), VDPステータス読み込み機能(>8802)</li>
</ul>
</ul>

<h4>動作環境</h4>
<ul>
<li>OS: Windows Me/2000 Pro</li>
<li>CPU: Intel製CPU</li>
<li>HW: ビデオカード</li>
</ul>

<h4>操作方法</h4>

　船スプライトデモのカートリッジROM(ship.bin)を選択して，動作確認をしてください．

<ul>
<li> [ファイル(F)] - [開く(O)]: カートリッジROMを選択して，エミュレーションの開始 </li>
<li> [ファイル(F)] - [再起動(R)]: エミュレータをリセットして，エミュレーションの再開</li>
<li> [ファイル(F)] - [停止(S)]: エミュレーションの停止</li>
<li> [ファイル(F)] - [終了(X)]: プログラムの終了</li>
<li> [ヘルプ(H)] - [バージョン情報(V)]: バージョン情報，著作権情報の表示</li>
</ul>

<h4>免責</h4>
　InfoPyutaは，フリーウェアです．また，いかなる保証もありません．
本ソフトウェアによって生じた損害等に関して，作者は一切責任を負いません．
InfoPyutaに関する情報やアップデートについては，以下のページ[2]を参照ください．<br>

　よりよいソフトウェアを目指すために，御利用いただいた皆様からの
御意見，御要望，バグ報告等を，下記の連絡先で御待ちしています．<br>

　なお，ぴゅう太(TM)は，TOMY社の登録商標です．
Windows(TM)は，マイクロソフトの登録商標です．<br>

<h4>連絡先</h4>
<ul>
<li><a href="mailto: Jays_Factory@excite.co.jp">電子メール</a></li>
<li><a href="http://pinecgi.zero.ad.jp/~zaa52609/BBS-Harmeln/wforum.cgi">掲示板</a></li>
</ul>

<h4>謝辞</h4>
　本プログラムを作成する際に，下記のプログラム，および，資料を参考にさせていただきました．
作者の皆様に，御礼を申し上げます．<br>

<ul>
<li>[1] M.Brent/Tursi: <a href="http://tursi.yiffco.com/games/ami99/">Ami99</a></li>
<li>[2] Jay: <a href="http://www.geocities.co.jp/SiliconValley/5604/">Jay's Factory</a></li>
<li>[3] Thierry Nouspikel: <a href="http://www.stanford.edu/~thierry1/ti99/titechpages.htm">The TI-99/4A Tech Pages</a></li>
<li>[4] N. Komatsu: <a href="http://www.st.rim.or.jp/~nkomatsu/ICcollection.html">半導体コレクション展示会場</a></li>
<li>[5] Texas Instruments: <a href="http://www.spies.com/arcade/schematics/DataSheets/9995DataSht.pdf">TMS 9995 16-bit Microcomputer</a></li>
<li>[6] C. Kaiser: <a href="http://www.floodgap.com/retrobits/tomy/">The Little Orphan: The Tomy Tutor</a></li>
</ul>

<hr>

<h2>空想上のぴゅう太(TM)仕様</h2>

<h3>目次</h3>
<ul>
<li> <a href="#1">1 はじめに</a> </li>
<li> <a href="#2">2 仕様</a> </li>
<li> <a href="#2.1">2.1 CPU</a> </li>
<li> <a href="#2.2">2.2 メモリマップ</a> </li>
<li> <a href="#2.3">2.3 VDP</a></li>
<li> <a href="#3">3 実装</a></li>
<li> <a href="#3.1">3.1 CPU</a></li>
<li> <a href="#3.2">3.2 I/O</a></li>
<li> <a href="#3.3">3.3 VDP</a></li>
<li> <a href="#4">4 カートリッジ</a> </li>
<li> <a href="#4.1">4.1 開発環境</a> </li>
<li> <a href="#4.2">4.2 カラーバーデモ</a> </li>
<li> <a href="#4.3">4.3 船スプライトデモ</a> </li>
<li> <a href="#5">5 まとめ</a> </li>
<li> <a href="#6">謝辞</a> </li>
</ul>

<h3><A NAME="1"></A>1 はじめに</h3>

　<a href=http://www.geocities.co.jp/SiliconValley/5604/>InfoNES</a>の仕事が，一段落ついたある日，ある掲示板で，｢XBOXでは，ファミコンやスーファミのゲームが，動作するか?｣という質問に対して，半分やけ気味に｢IntelliVisionやぴゅう太のゲームだって，動作する｣と発言する内容の会話を読みました．でも，この回答は，半分は正しいのですが，半分は間違っています．確かに，IntelliVisionのエミュレータは，この世に存在しますので，XBOXに移植するのは，比較的簡単でしょう．もう，動いているかもしれません．ただ，ぴゅう太のエミュレータは，この世には存在しなかったのです．<br>

　当時，ぴゅう太といえば，16ビットCPU，16色のグラフィックスを搭載して，一世を風靡したマシンです．この時，まだファミコンは発売されていません．また，スクランブルやフロッガーなどのアーケードからの移植ゲームなどが，カートリッジとして発売されました．このまま，ぴゅう太を思い出の中で，眠らせてしまっていいものだろうか？　これが，作者を揺り動かした，大きな力でした．<br>

　ぴゅう太のエミュレータを作ろう．<a href=http://www.geocities.co.jp/SiliconValley/5604/>InfoNES</a>の開発を通じて，エミュレータを開発する技術は，幸運にも手の中にありました．問題は，ぴゅう太に関する技術的な情報をどのように集めるかでした．しかし，この問題は，現時点でも，解決していません．皆さまからの情報をお待ちしております．

<h3><A NAME="2"></A>2 仕様</h3>

　本来，エミュレータは，実機の機能を忠実にまねることが，正しい動作です．ただ，前述したように，現時点では，実機の機能について，正確な情報が得られていない状況です．そこで，作者はぴゅう太の仕様を空想してみました．しかし，ただ単に，空想するだけでは，あまりにも非科学的なので，下記の事実から，空想をめぐらせてみました．

<ol>
<li> ぴゅう太のCPUは，TI社製のTMS9995である</li>
<li> ぴゅう太のVDPは，TI社製のTMS9918Aである</li>
<li> ぴゅう太は，RAM16KB, ROM20KBを搭載している(RAM16KBはVDP内に搭載)</li>
<li> ぴゅう太は，TI社製のTI-99/4Aをベースにして開発された</li>
</ol>

<h4><A NAME="2.1"></A>2.1 CPU</h4>

　ぴゅう太のCPUは，<a href=http://www.spies.com/arcade/schematics/DataSheets/9995DataSht.pdf>TMS9995</a>です．TI-99/4Aで利用されていた<a href=http://www.st.rim.or.jp/~nkomatsu/texasinstruments/TMS9900.html>TMS9900</a>からの差分は，下記の点です．

<ol>
<li> 内部RAM(256バイト)を搭載 </li>
<li> ステータスレジスタST10（OVEN:OVer flow ENable）が追加</li>
<li> 符号付整数の乗除算命令（MPYS,DIVS）が追加</li>
</ol>

<h4><A NAME="2.2"></A>2.2 メモリマップ</h4>

　メモリマップに関しては，下記をベースとして，空想する必要がありました．

<ol>
<li>ぴゅう太は，RAM16KB, ROM20KBを搭載している(RAM16KBはVDP内に搭載)</li>
<li>ぴゅう太のメモリマップは，TI-99/4Aのメモリマップと類似している可能性が高い</li>
</ol>

　以上から，空想したメモリマップを下記に示します．<br><br>

<table border=1>
<tr>
<th>開始アドレス</th>
<th>終了アドレス</th>
<th>用途</th>
</tr>

<tr>
<td>&gt;0000</td>
<td>&gt;0fff</td>
<td>外部ROM(BIOS)</td>
</tr>

<tr>
<td>&gt;1000</td>
<td>&gt;3fff</td>
<td>不明</td>
</tr>

<tr>
<td>&gt;4000</td>
<td>&gt;7fff</td>
<td>外部ROM(G-BASIC , カートリッジ)</td>
</tr>

<tr>
<td>&gt;8000</td>
<td>&gt;87ff</td>
<td>不明</td>
</tr>

<tr>
<td>&gt;8800</td>
<td>&gt;8fff</td>
<td>メモリマップI/O( VDP )</td>
</tr>

<tr>
<td>&gt;9000</td>
<td>&gt;efff</td>
<td>不明</td>
</tr>

<tr>
<td>&gt;f000</td>
<td>&gt;f0fb</td>
<td>内部RAM</td>
</tr>

<tr>
<td>&gt;f0fc</td>
<td>&gt;fff9</td>
<td>不明</td>
</tr>

<tr>
<td>&gt;fffa</td>
<td>&gt;fffb</td>
<td>内部メモリマップI/O</td>
</tr>

<tr>
<td>&gt;fffc</td>
<td>&gt;ffff</td>
<td>内部RAM(NMIベクタ)</td>
</tr>

</table>

<h4><A NAME="2.3"></A> 2.3 VDP </h4>

　VDPとは，Video Display Processorの略語で，グラフィック関連を管理するプロセッサです．ぴゅう太では，VDPとして，<a href=http://www.stanford.edu/~thierry1/ti99/tms9918a.htm>TMS9918A</a>が，採用されています．このチップは，MSX等でも採用されており，当時としては一般的なチップです．

<h3><A NAME="3"></A> 3 実装 </h3>

　InfoPyuta v0.02Jは，上記の仕様の一部を満たすエミュレータで，Windows MeやWindows 2000 Professional等で動作します．InfoPyutaの実装においては，TI-99/4AエミュレータであるAmi 99のソースコードを一部借用させて頂きました．ここで，作者のM.Brent/Tursi氏にお礼を申し上げます．

<h4><A NAME="3.1"></A> 3.1 CPU </h4>

　InfoPyuta v0.02Jにおいては，下記のオペコードが実装されています．

<ul>
<li> 算術命令: a,ab,abs,ai,dec,dect,div,inc,inct,mpy,neg,s,sb
<li> 分岐命令: b,bl,blwp,jeq,jgt,jhe,jh,jl,jle,jlt,jmp,jnc,jne,jno,jop,joc,rtwp,x,xop
<li> 比較命令,I/O命令: c,cb,ci,coc,czc,ldcr,sbo,sbz,stcr,tb,ckof,ckon,idle,rset,lrex
<li> ロード/ストア命令: li,limi,lwpi,mov,movb,stst,stwp,swpb
<li> 論理演算命令: andi,ori,xor,inv,clr,seto,soc,socb,szc,szcb,sra,srl,sla,src
</ul>

　InfoPyuta v0.02Jでは，起動時に，PC = >4000, WP = >f000という値が代入されます．ここで，>4000は，G-BASICやカートリッジとして供給される外部ROMの先頭アドレス，>f000は，内部RAMの先頭アドレスです．したがって，起動直後に，カートリッジ等に制御が移ることになります．<br>

　実際には，上記の動作は，>0000 - >1000に存在するBIOSに記述されるべき内容です．しかし，InfoPyuta v0.02Jでは，BIOSイメージを読み込む機能を実装していないので，上記のようにハードコーディングしています．万一，BIOSイメージを読み出す方法をご存知の方は，御連絡ください．<br>

<h5>VDPタイミング</h5>

　VDPが1画面を描画する時に，CPUは何クロック分実行するかを管理しないと，正確なエミュレーションはできません．
InfoPyuta v0.02Jでは，クロック数まで管理できていないため，VDPが1ライン描画する間に，22命令実行するように実装しました．これは，下記のデータに基づきます（( 19.91 / 262 ) / (0.0005 * 7) = 21.71...）．

<ul>
<li>VBLANK間隔: 19.91[ms]</li>
<li>1画面ライン数: 262</li>
<li>CPUクロック周波数: 2 [MHz] = 0.0005[ms]</li>
<li>1命令実行時の平均クロック数: 7</li>
</ul>

<h4><A NAME="3.2"></A> 3.2 I/O </h4>

　InfoPyuta v0.02Jでは，VDP I/Oとして，VDP RAM読み込み(>8800), VDPステータス読み込み機能(>8802), VDPレジスタ書き込み(>8C02), VDP RAM書き込み(>8C02, >8C00)を実装しています．下記に動作をまとめます．<br>

<ul>
<li> >8800: VDP RAMアドレスから1バイトを読み込み，アドレスポインタをインクリメント(+1)する</li>
<li> >8802: ステータスレジスタから1バイトを読み込み，ステータスレジスタをクリアして，割り込みをクリアする</li>
<li> >8C00: VDP RAMアドレスに1バイトを書き込み，アドレスポインタをインクリメント(+1)する</li>
<li> >8C02: VDPにコマンドを送信する(コマンドは2バイト)</li>
</ul>

　コマンドは，下記の2種類あります．<br><br>

<TABLE BORDER=1 >
<TR>
<TH>コマンド</TH>

<TH>1バイト目</TH>

<TH>2バイト目</TH>
</TR>

<TR>
<TD>レジスタへ書き込み</TD>

<TD>レジスタの内容</TD>

<TD>1 0 レジスタ番号(6ビット)</TD>
</TR>

<TR>
<TD>VDP RAMアドレスを設定</TD>

<TD>A6-A13</TD>

<TD>0 0 A0-A5(6ビット)</TD>
</TR>

</TABLE>

<h4><A NAME="3.3"></A> 3.3 VDP </h4>

　InfoPyuta v0.02Jでは，スタンダードモード（グラフィック1），スプライトを実装しています．TMS9918Aは，9本のレジスタ(VR0-VR7, Status)と16KBのVDP RAMを持っています．

<h5> スタンダードモード（グラフィック1）</h5>

　本モードは，VR0の7ビット目(重み:>01)とVR1の3,4ビット目(重み:>10,>08)が0の時に，選択されます．ただし，InfoPyuta v0.02Jでは，常に本モードが選択されます．<br>
　本モードでは，8x8ピクセルを1キャラクタとして，画面を32 x 24キャラクタで表示します．各キャラクタは，2色で表示され，"1"の時はフォアグランドカラー，"0"の時はバックグラウンドカラーで表示されます．このパレットは，フォアグランドカラー(4ビット) + バックグランドカラー(4ビット)で表現され，8キャラクタ毎に設定されます．各テーブルは，VDP RAMのいずれかの領域で，下記のような動作をします．
　
<ul>
<li> スクリーンイメージテーブル: 画面上の(0,0)から(31,23)までのキャラクタ番号列(32x24=768バイト)を格納したVDP RAM内の先頭アドレス</li>
<li> カラーテーブル: パレット列(キャラクタ番号0-7, ..., 248-255毎に32バイト)を格納したVDP RAM内の先頭アドレス</li>
<li> キャラクタパターンテーブル: 1キャラクタ毎に8バイトで表現したキャラクタパターン列(8x256=2048バイト)を格納したVDP RAM内の先頭アドレス</li>
</ul>

　各テーブルは，各レジスタで指定します．この指定方法について，下記にまとめます．なお，この当時のTI系のCPUでは，何ビット目という表記が，Intel系のCPU(普通の表記)とは，LSBとMSBが逆になっているので，注意してください．<br><br>

<TABLE BORDER=1 >
<TR>
<TH>ビット:<BR>
重み:</TH>

<TH>0<BR>
&gt;80</TH>

<TH>1<BR>
&gt;40</TH>

<TH>2<BR>
&gt;20</TH>

<TH>3<BR>
&gt;10</TH>

<TH>4<BR>
&gt;08</TH>

<TH>5<BR>
&gt;04</TH>

<TH>6<BR>
&gt;02</TH>

<TH>7<BR>
&gt;01</TH>
</TR>

<TR>
<TH>VR2</TH>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD COLSPAN="4">スクリーンイメージテーブル(<<10)</TD>
</TR>

<TR>
<TH>VR3</TH>

<TD COLSPAN="8">カラーテーブル(<<6)</TD>
</TR>

<TR>
<TH>VR4</TH>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD COLSPAN="3">キャラクタパタンテーブル(<11)</TD>
</TR>

</TABLE>

<h5>スプライト</h5>

　スプライトとは，スクリーン上の任意の箇所に表示される特殊なキャラクタのことです．
スタンダードモード1が選択されると，同時にスプライトも表示されます．
スプライトは，VR1の6ビット目(サイズ4(2x2))と連動して，8x8ピクセル(0)，もしくは，16x16ピクセル(1)で表示されます．
また，VR1の7ビット目(拡大(2倍))と連動して，2倍の拡大されて，表示されます．<br>

　同時に，32個のスプライトを表示可能ですが，画面は下記のような優先順位で表示されます．

<ul>
<li>黒</li>
<li>外部ビデオ入力</li>
<li>バックドロップ色(VR7の4-7ビット): 未実装</li>
<li>キャラクタ</li>
<li>スプライト#32</li>
<li>...</li>
<li>スプライト#0</li>
</ul>

　なお，スプライトは，VDPレジスタの下記のビットを利用して，表示されます．<br>

<br>

<TABLE BORDER=1 >
<TR>
<TH>ビット:<BR>
重み:</TH>

<TH>0<BR>
&gt;80</TH>

<TH>1<BR>
&gt;40</TH>

<TH>2<BR>
&gt;20</TH>

<TH>3<BR>
&gt;10</TH>

<TH>4<BR>
&gt;08</TH>

<TH>5<BR>
&gt;04</TH>

<TH>6<BR>
&gt;02</TH>

<TH>7<BR>
&gt;01</TH>
</TR>

<TR>
<TH>VR1</TH>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>

<TD>-</TD>

<TD>0</TD>

<TD>サイズ4(2x2)</TD>

<TD>拡大(2倍)</TD>

</TR>

<TR>
<TH>VR5</TH>

<TD>0</TD>

<TD COLSPAN="7">スプライト属性テーブル(<<7)</TD>
</TR>

<TR>
<TH>VR6</TH>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD>0</TD>

<TD COLSPAN="3">スプライトパターンテーブル(<<11)</TD>
</TR>


<TR>
<TH>VR7</TH>

<TD COLSPAN="4">-</TD>

<TD COLSPAN="4">バックドロップ色</TD>

</TR>

</TABLE>

<h5>スプライト属性テーブル</h5>

　スプライト属性テーブルは，VR6で指定されるアドレスに記述されるテーブルで，下記のような形式をしています．
このテーブルは，32エントリを持っており，各エントリは，4バイト長なので，テーブル長は，最大で>100バイトとなります．

<br>

<TABLE BORDER=2 CELLSPACING=2 CELLPADDING=2 >
<TR>
<TD></TD>

<TD>バイト1</TD>

<TD>バイト2</TD>

<TD>バイト3</TD>

<TD COLSPAN="2">バイト4</TD>
</TR>

<TR>
<TD>スプライト0</TD>

<TD>Y座標-1</TD>

<TD>X座標</TD>

<TD>パターン番号</TD>

<TD>クロックビット</TD>

<TD>スプライト色</TD>

</TR>

<TR>
<TD>スプライト1</TD>

<TD>
<CENTER><P>&quot;</P></CENTER>
</TD>

<TD>
<CENTER><P>&quot;</P></CENTER>
</TD>

<TD>
<CENTER><P>&quot;</P></CENTER>
</TD>

<TD>
<CENTER><P>&quot;</P></CENTER>
</TD>

<TD>
<CENTER><P>&quot;</P></CENTER>
</TD>
</TR>
</TABLE>

<br>

　スプライトの位置は，スプライトの左上で指定します．
Y座標は，デクリメント(-1)した値を格納しますので，一番上のラインのY座標は，>FF(-1)となります．
したがって，Y座標は，>FFから>BEとなります．
ファミリーコンピュータ(TM)でも，このような仕様なのですが，走査線とのタイミングの都合なのでしょう．

<h5>スプライトパターンテーブル</h5>

　スプライト番号は，スプライトパターンテーブルでの位置を参照します．そして，スプライト色は，下位4ビットで規定された色となります．スプライト属性テーブルは，すべてのスプライトを定義する必要はなく，X座標に>D0を指定することで，エンドマークとして，以下のエントリを無視するように指定できます．

<br>

　スプライトパターンテーブルは，8バイト長(8x8)，もしくは，32バイト長(16x16)のエントリから構成されます．
8x8の場合，ビットに"1"を指定すると，スプライト属性テーブルで指定した色のピクセル，
ビットに"0"を指定すると，透明色のピクセルとなります．<br>

　また，16x16を指定すると，下記のような配置で，8x8のスプライトを配置したのと同じになります．<br><br>

1 3<BR>
2 4</p>

　したがって，16x16を指定して，32スプライトのパターンを格納するためには，>400(32x32)バイトが必要になります．

<h5>ステータスレジスタ</h5>

　InfoPyuta v0.02Jにおいては，>8802の値を読み込むと，ステータスレジスタを返却します．
ステータスレジスタの仕様を下記に示します．<br><br>

<TABLE BORDER=1 >
<TR>
<TH>ビット:<BR>
重み:</TH>

<TH>0<BR>
&gt;80</TH>

<TH>1<BR>
&gt;40</TH>

<TH>2<BR>
&gt;20</TH>

<TH>3<BR>
&gt;10</TH>

<TH>4<BR>
&gt;08</TH>

<TH>5<BR>
&gt;04</TH>

<TH>6<BR>
&gt;02</TH>

<TH>7<BR>
&gt;01</TH>
</TR>

<TR>
<TH>ステータス</TH>

<TD>VBLANK</TD>

<TD>Coinc</TD>

<TD>5スプライト</TD>

<TD COLSPAN="5">スプライト番号(5番目)</TD>

</TR>
</TABLE>

<br>

　このうち，InfoPyuta v0.02Jでは，下記の1機能だけを実装しています．

<ul>
<li>VBLANK: 表示可能領域の最終ライン(244ライン目)を描画終了した時に，1にセットされる．もし，割込みが有効（VR1の2ビット目）であれば，このビットが1の時，割込みピンはLowになり，このビットが0の時，割込みピンはHighになる

</li>
</ul>

　ステータスレジスタを利用することで，CPUとVDPが通信することが可能になります．
すなわち，CPU(ROMファイル)側では，1画面分の処理を終了してから，VBLANKの開始を検出するまでウェイト処理をして，VBLANKに同期した処理を記述することが可能です．
これは，当時のゲーム(ファミコン(TM)などでも，広く行なわれた)でよく行なわれた手法です．<br>

　また，重要な注意点として，VDP側は，CPU側が>8802への読み込みを実行して，割込みピンをクリア(High)にするまで，VBLANKを続行します．
InfoPyuta v0.02Jでは，常に割込み有効として処理をしていますので，VR1の2ビット目は，無視されます．

<h3><A NAME="4"></A>4 カートリッジ</h3>

　InfoPyuta v0.02Jでは，カートリッジのROMイメージを，ファイルとして読み込んで，外部ROM(>4000->7fff)にロードします．商用ゲームの実行には，BIOS(>0000->0fff)も必要なりますが，著作権等の問題も存在するので，今後の課題としたいと思います．ちなみに，TI-99/4Aにおいては，TI社がBIOS ROMの著作権を放棄しているようです．日本でも，X68000において，SHARP社が同様にBIOS ROMの著作権を放棄しています．

<h4><A NAME="4.1"></A>4.1 開発環境</h4>

　InfoPyuta v0.02Jの動作を確認するためには，なんらかのカートリッジのROMイメージを用意する必要があります．ここでは，TMS9900のアセンブラを利用して，ROMイメージを開発する方法について，まとめます．なお，TMS9900アセンブラとしては，Macroassembler ASを利用しました．

<h5>1. ダウンロード</h5>
<a href="http://john.ccac.rwth-aachen.de:8000/as/download.html">
The Macroassembler AS</a>から，Win32 Binariesをダウンロードします．<br>

<h5>2. インストール</h5>
アーカイブをC:\ASなどに解凍します．<br>

<h5>3. 環境設定</h5>
AUTOEXEC.BATに，下記を追加します．<br><br>

SET PATH=......;C:\AS\BIN<br>
SET ASCMD=@c:\as\lib\as.rc<br><br>

C:\AS\LIBに，as.rcというファイルを新規に作成して，下記の一行を追加します．<br><br>

-i c:\as\include<br><br>

<h5>4. ASMファイル作成</h5>
例えば，test.asmというファイル名で，下記の内容のファイルを作成します．<br><br>

　　　　cpu tms9900<br>
　　　　org 4000H<br>
label:<br>
　　　　inc (r1)<br>
　　　　jmp label <br>
　　　　end<br>

<h5>5. アセンブル</h5>

下記のコマンドを実行して，中間ファイル（test.p）を生成します．<br><br>

C> asw test.asm<br><br>

下記のコマンドを実行して，バイナリファイル（test.bin）を生成します．<br><br>


C> p2bin -r 0x4000-0x7fff test.p<br><br>

<h4><A NAME="4.2"></A>4.2 カラーバーデモ </h4>

　本デモ(colorbar.bin)は，左からパレット0 - パレット15の色のバーを表示するデモで，ぴゅう太の起動画面を作成しようとして，挫折した結果できました．詳細は，別途公開するカラーバーデモのソースを参照ください．VDPとI/Oする方法が分かると思います．

<h4><A NAME="4.3"></A>4.3 船スプライトデモ </h4>

　本デモ(ship.bin)は，複数の船(スクランブル風)が飛ぶデモです．
詳細は，別途公開する船スプライトデモのソースを参照ください．
スプライト機能の利用方法と，VBLANKを利用したプログラミングを説明しています．

<h3><A NAME="5"></A>5 まとめ</h3>
　InfoPyuta v0.02Jは，世界初のぴゅう太エミュレータとして，開発されました．
本リリース(v0.02J)によって，コントローラを除いたゲーム(デモ)レベルであれば，自由に記述できるレベルまで到達できたと思っています．<br>

　ただし，本エミュレータは，商用ゲームなどは動作せず，プロジェクトとしても，ぴゅう太に関する詳細な技術情報も得られてないという状態です．作者の力だけでは，どうにも成りません．このプロジェクトを成功させるためには，皆様からの情報が，どうしても必要です．今後は，コントローラ，および，VDPの実装を進めていきたいと思います．<br>

<h3><A NAME="6"></A>謝辞</h3>

　InfoPyuta開発のベースとなったAmi99の作者，M.Brent/Tursi氏に感謝します．また，議論につきあってくださったHarmelnプロジェクトの関係者，はーめるん氏に感謝します．VDPに関する詳細な情報を公開してくださったThierry Nouspikel氏に感謝します．<br><br>

<hr>

InfoPyuta 0.02J, Copyright (c) 2001 Jay's Factory, All rights reserved.<br>

</body>
</html>
