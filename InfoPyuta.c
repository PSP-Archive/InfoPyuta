/*===================================================================*/
/*                                                                   */
/*  InfoPyuta.cpp : C++ファイル(ぴゅう太エミューレータ)              */
/*                                                                   */
/*  2001/04/19    Jay's Factory                                      */
/*                                                                   */
/*===================================================================*/

/*-------------------------------------------------------------------*/
/*  インクルードファイル                                             */
/*-------------------------------------------------------------------*/

#include <stdio.h>
#include "cpu9900.h"
#include "InfoPyuta.h"
#include "InfoPyuta_System.h"
#include "InfoPyuta_Vdp.h"
#include "pg.h"

/*-------------------------------------------------------------------*/
/*  ぴゅう太リソース                                                 */
/*-------------------------------------------------------------------*/

Byte RAM[ 0x4000 ];             /* 外部RAM */
Byte ROM[ 0x5000 ];             /* 外部ROM */
Byte INTLRAM[ 0x100 ];          /* 内部RAM */           
Byte CRU[ 0x1000 ];	            /* CRU空間 (不要?) */

Word Scanline;                  /* スキャンライン */

/*-------------------------------------------------------------------*/
/*  ぴゅう太エミュレーション                                         */
/*-------------------------------------------------------------------*/
int InfoPyuta_Main()
{
  /* ぴゅう太初期化 */
  InfoPyuta_Reset();

  /* ぴゅう太起動 */
  InfoPyuta_Cycle();

  return(1);
}

/*-------------------------------------------------------------------*/
/*  ぴゅう太初期化                                                   */
/*-------------------------------------------------------------------*/
int InfoPyuta_Reset()
{
  /* ダミー命令セット(動作確認用) */
  ROM[ 0x0000 ] = 0xf0;                 /* WP:内部RAMを設定 */
  ROM[ 0x0001 ] = 0x00;
  ROM[ 0x0002 ] = 0x40;                 /* PC:ROMカートリッジを設定 */
  ROM[ 0x0003 ] = 0x00;

#if 0
  ROM[ 0x1000 ] = 0x04;
  ROM[ 0x1001 ] = 0x50;
  ROM[ 0x1002 ] = 0x40;
  ROM[ 0x1003 ] = 0x00;
  ROM[ 0x1004 ] = 0x04;
  ROM[ 0x1005 ] = 0x40;
#endif

  /* CPU命令セット生成 */
  buildcpu();

  /* CPUリセット */
  reset();

  /* VDPリセット */
  VDPreset();

  /* スキャンラインを初期化 */
  Scanline = 0;

  return(0);
}

/*-------------------------------------------------------------------*/
/*  ぴゅう太エミュレーションの水平同期処理                           */
/*-------------------------------------------------------------------*/
int InfoPyuta_HSync()
{
  /*-------------------------------------------------------------------*/
  /*  VDP割込みピンチェック                                            */
  /*-------------------------------------------------------------------*/
  if ( INT_PIN )
  {
    /* VDP割込みピンがリセットされるまで待つ */
    return ( 0 );
  }

  /*-------------------------------------------------------------------*/
  /*  次のスキャンライン                                               */
  /*-------------------------------------------------------------------*/
  Scanline = ( Scanline == VBLANK_END ) ? 0 : Scanline + 1;

  /*-------------------------------------------------------------------*/
  /*  スキャンライン毎の処理                                           */
  /*-------------------------------------------------------------------*/
  switch ( Scanline )
  {
    case ON_SCREEN_START:
      /* なにもしない */      
      break;

    case VBLANK_START:
      /* 垂直復帰フラグをセット */
      VDPST |= VDPST_INT;

      /* VDP割込みピンをセット */
      INT_PIN = 0x01;

      /* 画面生成 */
      VDPgraphics();

      /* 画面更新 */
      InfoPyuta_LoadFrame();

      break;

    case VBLANK_END:
      /* なにもしない */
      break;
  }
  return( 0 );
}

/*-------------------------------------------------------------------*/
/*  ぴゅう太エミュレーションループ                                   */
/*-------------------------------------------------------------------*/
int InfoPyuta_Cycle()
{
  /* エミュレーションループ */
  for (;;)
  {
    /* 水平同期毎に何命令実行するか(暫定) */
    for ( int i = 0; i < INST_PER_HSYNC; i++ )
    {
      /* 1命令実行 */
      do1();
    }

    /* 水平同期毎の処理 */
    InfoPyuta_HSync();

    /* ウェイト処理 */
    InfoPyuta_Wait();

    /* 動作確認用 */
    char szMsg[ 256 ];
    sprintf( szMsg, "Opcode: 0x%x, PC: 0x%x, R1: 0x%x", in, PC, romword( 0xf002 ) );
#if 0
    warn( szMsg );
#endif
	sceCtrlPeekBufferPositive(&paddata, 1);
	if(paddata.buttons & CTRL_LTRIGGER) break;
	
	extern int bSleep;
	if(bSleep)
		while(bSleep) pgWaitV();
  }

  return(0);
}

/*-------------------------------------------------------------------*/
/*  カセットをぴゅう太にロード                                       */
/*-------------------------------------------------------------------*/
int InfoPyuta_Load( const char *pszFileName )
{
  /* ROMイメージをメモリに読み込み */
  if ( InfoPyuta_ReadRom( pszFileName ) < 0 )
    return -1;

  /* InfoPyutaをリセット */
  if ( InfoPyuta_Reset() < 0 )
    return -1;

  /* 成功 */
  return 0;
}

/*-------------------------------------------------------------------*/
/* 空想上のぴゅう太メモリマップ                                      */
/* >0000 - >0fff  外部ROM(BIOS)                                      */
/* >1000 - >3fff  不明                                               */
/* >4000 - >7fff  外部ROM(G-BASIC , カートリッジ)                    */
/* >8000 - >8800  不明                                               */
/* >8800 - >8fff  メモリマップI/O ( VDP )                            */
/* >9000 - >efff  不明                                               */
/* >f000 - >f0fb  内部RAM                                            */
/* >f0fc - >fff9  不明                                               */
/* >fffa - >fffb  内部メモリマップドI/O                              */
/* >fffc - >ffff  内部RAM(NMIベクタ)                                 */
/*-------------------------------------------------------------------*/

/*-------------------------------------------------------------------*/
/*  CPU上メモリからバイトを読み込み                                  */
/*-------------------------------------------------------------------*/

Byte rcpubyte(Word x)
{
  switch ( x & 0xc000 )
  {
    /* 外部ROM(BIOS) */
    case 0x0000:
     
      if ( 0x0000 <= x && x <= 0x0fff )
      {
          return ROM[ x & 0x0fff ];
      }
      break;

    /* 外部ROM(G-BASIC，カートリッジ) */
    case 0x4000:
      return ROM[ ( x & 0x3fff ) + 0x1000 ];

    /* メモリマップI/O ( VDP ) */
	  case 0x8000:
	  if ( 0x8800 <= x && x <= 0x8fff )
	  {
      /* VDPデータ読み込み */
		  return( rvdpbyte( x ) );
	  }
    break;

#if 0
    /* 外部RAM */
    case 0xa000:
      return RAM[ x & 0x3fff ];
#endif

    /* 内部RAM */
    case 0xc000:
      if ( 0xf000 <= x && x <= 0xf0f9 )
      {
        return INTLRAM[ x & 0x00ff ];
      } 
      else if ( 0xfffc <= x && x <= 0xffff )
      {
        return INTLRAM[ x & 0x00ff ];
      }
      break;
  }

  /* データバス上に残っている値 */
  return 0x00;
}

/*-------------------------------------------------------------------*/
/*  CPU上メモリにバイトを書き込み                                    */
/*-------------------------------------------------------------------*/
void wcpubyte(Word x, Byte c)
{
  switch ( x & 0xc000 )
  {
    /* メモリマップI/O ( VDP ) */ 
    case 0x8000:
      if ( 0x8800 <= x && x <= 0x8fff )
	    {  
        /* VDPに書き込み */
		    wvdpbyte(x,c);
	    }
      break;
    
#if 0
    /* 外部RAM */
    case 0xa000:
      RAM[ x & 0x3fff ] = c;
      break;
#endif

    /* 内部RAM */
    case 0xc000:
      if ( 0xf000 <= x && x <= 0xf0f9 )
      {
        INTLRAM[ x & 0x00ff ] = c;
      } 
      else if ( 0xfffc <= x && x <= 0xffff )
      {
        INTLRAM[ x & 0x00ff ] = c;
      }
      break;
  }
}

/*-------------------------------------------------------------------*/
/*  CPU上メモリからワードを読み込み                                  */
/*-------------------------------------------------------------------*/
Word romword(Word x)
{ 
	x&=0xfffe;		/* LSBは落とす */
	return((rcpubyte(x)<<8)+rcpubyte(x+1));
}

/*-------------------------------------------------------------------*/
/*  CPU上メモリにワードを書き込み                                    */
/*-------------------------------------------------------------------*/
void wrword(Word x, Word y)
{ 
	x&=0xfffe;		/* LSBは落とす */
	wcpubyte(x,(Byte)(y>>8));
	wcpubyte(x+1,(Byte)(y&0xff));
}

/*-------------------------------------------------------------------*/
/*  CRUからビットを読み込み                                          */
/*-------------------------------------------------------------------*/
int rcru(Word ad)
{
	int ret;                      /* テンポラリ */

	ad=(ad&0x0fff);               /* 実際のCRU線を取得 */
	ret=1;												/* デフォルトの返値 */

	return(ret);
}

/*-------------------------------------------------------------------*/
/*  CRUにビットを書き込み                                            */
/*-------------------------------------------------------------------*/
void wcru(Word ad, int bt)
{
	ad=(ad&0x0fff);										/* 実際のCRU線を取得 */
	
	if (bt)												    /* データを書き込む */
		CRU[ad]=1;
	else
		CRU[ad]=0;
}

/*-------------------------------------------------------------------*/
/*  VDPチップから読み込み                                            */
/*-------------------------------------------------------------------*/
Byte rvdpbyte(Word x)
{ 
  Word z;

	if ( ( x >= 0x8c00 ) || ( x & 0x0001 ) ) 
	{
    /* 書き込み用アドレス */
    return(0);                        
	}

	if (x&0x0002)
	{
    /* ステータス読み込み，クリア, 割込みクリア */
		z=VDPST;
		VDPST = 0;
    INT_PIN = 0x00;
		return((Byte)z);                  
	}
	else
	{
    /* データ読み込み */
		z=VDP[VDPADD&0x3fff];           

    /* 自動的にインクリメント */
	  VDPADD++;									      
		return ((Byte)z);
  }
}

/*-------------------------------------------------------------------*/
/*  VDPチップへの書き込み                                            */
/*-------------------------------------------------------------------*/
void wvdpbyte(Word x, Byte c)
{
  char szMsg[512];

	if ( (x < 0x8c00) || ( x & 0x0001 ) ) 
	{
    /* 読み込み用アドレス */
		return;				
	}

	if (x&0x0002)
	{
    /* VDP書き込みアドレスを更新 */
		VDPADD=(VDPADD>>8)|(c<<8);

    /* アクセスカウントをインクリメント */
		vdpaccess++;
		if (vdpaccess==2)
		{ 
			if (VDPADD&0x8000)
			{ 
        /* VDPレジスタへの書き込み */
				wVDPreg((Byte)((VDPADD&0x0700)>>8),(Byte)(VDPADD&0x00ff));
        /* 再描画フラグをセット */
				redraw_needed=1;
			}
      /* アクセスカウントをリセット */
			vdpaccess=0;
		}
	}
	else
	{ 
    /* VDP RAMに書き込み */
		VDP[(VDPADD++)&0x3fff]=c;

    sprintf( szMsg, "VDPADD: 0x%x, c: 0x%x", ((VDPADD-1)&0x3fff), c);
#if 0
    warn( szMsg );
#endif

    /* 再描画フラグをセット．もう少しスマートな方法はないかなぁ? */
    redraw_needed=1;
	}
}

/*-------------------------------------------------------------------*/
/*  VDPレジスタに書き込み                                            */
/*-------------------------------------------------------------------*/
void wVDPreg(Byte r, Byte v)
{ 
	int t;                        /* テンポラリ */

	VDPREG[r]=v;                  /* レジスタにセット */

	if (r==7)
	{
		t=v&0xf;                    /* TODO: BG色であれば，パレットを更新 */
#if 0
    TIPAL[0].r=red[t];
		TIPAL[0].g=green[t];
		TIPAL[0].b=blue[t];
#endif
  }
}
